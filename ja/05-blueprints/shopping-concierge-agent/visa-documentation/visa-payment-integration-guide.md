# Visa Intelligent Commerce 統合 - 実装ガイド

## 概要

この包括的なガイドでは、トークン化、認証、決済指示、およびコマースシグナルを含む Visa の Intelligent Commerce スイートを AI エージェントアプリケーションに統合するための完全なプロセスフローを説明します。この統合により、トランザクションライフサイクル全体を通じて機密カードデータを保護しながら、安全かつセキュアな決済が可能になります。

## 始める前に：完全な統合ジャーニーの理解

Visa 決済統合は、安全でシームレスな決済体験を作成するために連携する5つの異なるフェーズで構成されています：

**フェーズ 1：前提条件とオンボーディング**（[オンボーディングプロセス](#オンボーディングプロセス) を参照）

- Visa Intelligent Commerce プラットフォームへのオンボーディング
- API 認証情報の取得（API キー、キー ID、クライアントアプリ ID）
- 技術インフラの設定（HTTPS、データベース、FIDO2 対応環境）

**フェーズ 2：トークン化** - セキュアトークンを受け取るためのカード番号の登録（カードごとに1回のセットアップ）

**フェーズ 3：認証 - パスキーセットアップ** - FIDO2 を使用した決済トークンの特定デバイスへのバインディング（デバイスごとに1回のセットアップ）

**フェーズ 4：購入意図** - 取引のための消費者の指示と意図のキャプチャ

**フェーズ 5：購入完了** - セキュアな決済認証情報/クリプトグラムの生成と使用

このガイドはフェーズ 2-5 に焦点を当て、決済フロー自体の技術的な実装を詳述します。これらのフェーズに進む前に、上記の前提条件と要件セクションで説明されているように、Visa Intelligent Commerce にオンボーディングし、必要なすべての認証情報を取得してフェーズ 1 を完了していることを確認してください。

このガイド全体の図では、各ステップが統合ジャーニー全体のどこに位置するかを理解できるように、これらのフェーズ番号を参照しています。

## アーキテクチャの理解

### エージェントフレームワークオプション

決済エージェントは、ユーザーとマーチャント間のインテリジェントな仲介者として機能し、セキュリティとユーザー体験を維持しながら決済フロー全体をオーケストレーションします。このエージェントを構築するための主な2つのアーキテクチャアプローチがあります：

**AWS AgentCore フレームワーク**：これは、洗練されたオーケストレーション機能を持つ AI エージェントを作成するための Amazon の専用フレームワークです。AgentCore は、複雑な多段階決済フローに最適な組み込みの状態管理、会話処理、および統合パターンを提供します。ユーザーセッションの管理、複数のサービス間の調整、およびインタラクション全体にわたるコンテキストの維持の複雑さを処理します。

**Model Context Protocol（MCP）サーバー**：MCP は、エージェントからサービスへの通信に対する標準化されたアプローチを提供します。エージェントが Visa の決済プラットフォームのような外部サービスとどのように通信するかについて明確なプロトコルを定義します。MCP サーバーは独立してデプロイでき、エージェントロジックとサービス統合の間に明確な分離を提供します。

> **重要な注意**：AWS AgentCore と MCP サーバーのデプロイメント両方の具体的な実装パターン、設定要件、およびベストプラクティスについては、別の詳細なアーキテクチャガイドが用意されています。このガイドは決済統合フロー自体に焦点を当てています。

### Visa 決済プラットフォーム

エージェントは、決済エコシステムで特定の目的を果たす3つの異なるが相互接続された Visa サービスと統合します：

**Visa Token Service（VTS）**：これは決済を行う機能を開始するためのワークフローの開始をキックオフします。VTS は、提供された実際のカード番号（PAN）に基づいて対応するセキュアトークン ID を提供する重要なプロセスを処理します。また、決済トークンと特定のユーザーデバイス間の暗号化リンクを作成するデバイスバインディングも管理します。このバインディングにより、トークンが侵害されても、認証されていないデバイスからは使用できません。VTS は、パスキー作成を許可する前に決済認証情報にリンクされた消費者のアイデンティティを確立し信頼を確立する OTP 検証を含むステップアップ認証フローも処理します。

**Visa Intelligent Commerce（VIC）**：VIC は実際の決済トランザクションをオーケストレーションします。購入指示を管理します。これは本質的に、ユーザーがアイデンティティを検証し、特定のトランザクションまたはトランザクションのセットに同意したことを証明する事前認証済みの決済意図です。VIC は、エージェントがトランザクションを処理するためにマーチャントエンドポイントで利用するクリプトグラム - 決済認証情報を生成します。

**Visa Auth iFrame**：これは、パスキー操作のためのセキュアなインターフェースを提供するユーザー向けコンポーネントです。iFrame は分離されたセキュリティコンテキストで実行され、アプリケーションがパスキー作成または認証プロセスに直接アクセスできないようにします。ユーザーのデバイスとの複雑な FIDO2 プロトコルインタラクションすべてを処理し、認証プロンプトのセキュアな表示を管理し、必要な認証証明のみをアプリケーションに返します。

## 前提条件と要件

### Visa Intelligent Commerce へのオンボーディング

Visa 決済統合を実装する前に、まず AI エージェントを Visa Intelligent Commerce プラットフォームにオンボーディングする必要があります。このオンボーディングプロセスにより、セキュアなエージェントベースの決済処理に必要な統合サービスへのアクセスが付与されます。

### Visa Intelligent Commerce の理解

Visa Intelligent Commerce は、安全かつセキュアでパーソナライズされた AI コマースを大規模に実現する包括的なプラットフォームです。プラットフォームは、エージェントベースのトランザクションを促進するために連携する5つの統合サービスを提供します：

- **トークン化**：Visa 対応マーチャントで使用するためのエージェント固有の決済トークン
- **認証**：セキュアなカード保有者認証のためのステップアップ検証とパスキーセットアップ
- **決済指示**：決済リクエストが認証されたユーザー指示と一致することを確認するためのコントロール
- **シグナル**：紛争解決とトランザクション追跡のためのコマースシグナル
- **パーソナライゼーション**：強化されたパーソナライズされた体験のためのユーザーインサイト（ユーザーの同意あり）

### オンボーディングプロセス

統合を開始するには、[developer.visa.com](https://developer.visa.com) の Visa Developer Portal を通じてエージェントオンボーディングプロセスを完了する必要があります。アクセスを受け取るには GDLAICommerceSupport@visa.com にメールしてください。

[こちら](https://globalclient.visa.com/AI-Commerce) から直接メッセージすることもできます。

オンボーディング中に以下を行います：

**アプリケーションの登録**：Visa Developer Platform でプロジェクトを作成し、AI エージェントアプリケーションを登録

**必要な認証情報の取得**：以下の認証情報を受け取ります：
- **API キー**：VTS および VIC API コールのためのプライマリ認証情報（サンドボックスと本番用に別々のキー）
- **キー ID**：暗号化されたペイロードを含む VIC 操作のための識別子
- **クライアントアプリ ID**：Visa のエコシステム内での登録済みアプリケーション識別子（テスト用に「VICTestAccountTR」など）

**API ドキュメントへのアクセス**：以下を含む包括的な技術ドキュメントへのアクセスを取得：
Visa Intelligent Commerce – [API ドキュメント](https://developer.visa.com/capabilities/visa-intelligent-commerce/docs-getting-started)
[Visa Intelligent Commerce – MCP](https://github.com/visa/mcp)

### 地域の可用性

Visa Intelligent Commerce は以下の地域で利用可能です：
- 北米
- アジア太平洋
- ヨーロッパ
- CEMEA（中央ヨーロッパ、中東、アフリカ）
- LAC（ラテンアメリカおよびカリブ海）

### 料金と条件

プラットフォームは開発とテストのためにサンドボックス環境で無料で使用できます。本番デプロイメントについては、価格と条件について直接 Visa にお問い合わせください。

### 技術要件

オンボーディング後、実装は以下の技術要件を満たす必要があります：

**HTTPS 対応 Web アプリケーション**：Visa サービスとのすべての通信には、信頼された認証局からの有効な SSL/TLS 証明書が必要

**データベースインフラ**：ユーザープロファイル、決済トークン、パスキーデータ、およびトランザクション履歴のための永続ストレージ

**FIDO2 対応ブラウザ**：最新のブラウザ（Chrome 67+、Safari 14+、Edge 18+）とセキュア認証機（Touch ID、Windows Hello、またはハードウェアセキュリティキー）へのアクセス

### はじめに

1. [developer.visa.com/capabilities/visa-intelligent-commerce](https://developer.visa.com/capabilities/visa-intelligent-commerce) にアクセス
2. 「Start Project」をクリックしてオンボーディングプロセスを開始
3. 各統合サービスの API ドキュメントを確認
4. Visa アカウントチームと連携して開発とテスト用のサンドボックス認証情報を取得
5. この実装ガイドに従って AI エージェントに決済フローを統合


## フェーズ 2：カードトークン化 - セキュア決済の基盤

カードトークン化は、ユーザーの実際のカード番号を安全に保存して再利用できるセキュアトークンに変換する1回限りのセットアッププロセスです。このフェーズは、ユーザーが最初にエージェントに支払い方法を追加するときに発生します。

### ステップ 1：PAN 登録 - トークン化プロセスの開始

登録プロセスは、ユーザーがカード詳細を提供したときに開始されます。これは実際のカード番号を扱う唯一の機会であり、そのときでも即座に暗号化する必要があります。

**ユーザー体験**：アプリケーションは、ユーザーがカード番号（PAN）、CVV2 セキュリティコード、有効期限、および請求先住所を入力するセキュアフォームを提示します。このフォームは、これが1回限りのセットアップであり、カードがセキュアにトークン化されることを明確に伝える必要があります。

**技術プロセス**：収集後、カードデータは Visa の JWE（JSON Web Encryption）形式を使用して暗号化する必要があります。この暗号化は、データがサーバーに到達する前にクライアント側で行われます。暗号化されたペイロードは VTS の PAN 登録エンドポイントに送信されます。VTS はセキュア環境でデータを復号化し、カード詳細を検証し、登録セッションを作成します。

**受信内容**：VTS は `vPanEnrollmentID` を返します。これはこの特定の登録セッションを表す一時的な識別子です。これは最終的なトークンではありません - 登録プロセスを正常に開始したことを証明するセッション ID と考えてください。また、ユーザーに確認のために表示できる最後の4桁や有効期限などの基本的なカードメタデータも受け取ります。

**一時ストレージ**：登録 ID はメモリまたは短期間のセッションストアに保持する必要があります。次のステップで必要ですが、長期保存を目的としていません。使用されない場合、通常数分で期限切れになります。

### ステップ 2：トークンプロビジョニング - 永続的な決済トークンの作成

登録 ID を手に入れたら、将来のすべてのトランザクションに使用される実際の決済トークンをリクエストします。

**プロビジョニングリクエスト**：登録 ID をデバイスとリスクプロファイルに関する追加コンテキストとともに VTS に送信します。これには、ユーザーのデバイス（タイプ、モデル、オペレーティングシステム）、IP アドレス、およびリスク指標に関する情報が含まれます。また、このトークンがエージェントベースのコマースシナリオで使用されることを示すために、プレゼンテーションタイプを「AI_AGENT」と指定します。

**VTS 処理**：VTS は登録 ID を取得し、セキュアストレージから関連するカードデータを取得し、一意のトークンを生成します。このトークンは元のカードに暗号的にリンクされていますが、カード番号を明らかにするようにリバースエンジニアリングすることはできません。VTS はまた、追跡用のトークン参照 ID を作成し、トークンをアプリケーションに関連付けます。

**受信内容**：レスポンスにはいくつかの重要な情報が含まれています。`vProvisionedTokenID` はプライマリ決済識別子です - これは将来のすべての決済操作で使用するものです。`tokenReferenceID` は追跡と調整のための追加参照を提供します。また、最後の4桁（ユーザーに表示するため）、有効期限、およびオプションで UI にカードブランドとデザインを表示するために使用できるカードアート URL を含むトークンメタデータも受け取ります。

**永続ストレージ**：これはユーザーのプロファイルにリンクされたデータベースに保存するデータです。トークン ID はすべての決済操作のプライマリキーになります。最後の4桁はユーザーが使用しているカードを識別するのに役立ちます。有効期限はトークンをいつ更新する必要があるかを知らせます。

**重要なセキュリティポイント**：データベースには実際のカード番号や CVV2 が含まれることはありません。トークン ID と表示メタデータのみを保存します。データベースが完全に侵害されても、攻撃者はこの情報を使用して不正な購入を行うことはできません。パスキー認証データ（フェーズ 3 で提供される）がなく、VIC を経由せずに有効なクリプトグラムを生成できないためです。


## フェーズ 3：パスキーセットアップ - 決済とデバイスのバインディング

パスキーセットアップは、FIDO2 標準を使用して決済トークンとユーザーの特定のデバイス間に暗号的バインディングを作成します。トークン化と同様に、これは1回限りのセットアッププロセスです。

### ステップ 3：セキュアセッションの初期化

すべてのパスキー操作は、Visa の Auth iFrame とのセキュアセッションを確立することから始まります。

**2ステップハンドシェイク**：iFrame の初期化は2ステップのプロセスです。まず、API キーとクライアントアプリ ID を使用して Auth iFrame エンドポイントに GET リクエストを行います。これはリクエスト ID を返し、iFrame の準備ができていることを確認します。次に、リクエスト ID と認証セッションを作成するコマンドを使用して同じエンドポイントに POST します。この2ステッププロセスにより、セッションが適切に初期化され、特定のタイプのリプレイ攻撃が防止されます。

**受信内容**：レスポンスにはいくつかの重要な要素が含まれています。`secureToken` は、iFrame とのアクティブで認証されたセッションがあることを証明するために後続の VTS API コールで使用される暗号化されたセッショントークンです。`dfpSessionID` は詐欺検出に使用されるデバイスフィンガープリントセッション識別子です。`requestID` は後続のすべての iFrame 操作をこの特定のセッションに結び付けます。

**セッションライフサイクル**：このセキュアトークンは現在の操作（パスキー作成または認証）に対してのみ有効です。一度使用すると期限切れになります。これは、すべてのトランザクションに新しいセッションが必要であることを意味しますが、これは非効率に見えるかもしれませんがセキュリティにとって重要です - トークンの再利用攻撃を防ぎ、各操作が独立して認証されることを保証します。

**メモリと永続化**：セキュアトークンは操作中はメモリに保持する必要がありますが、データベースに永続化してはいけません。設計上一時的なものです。ユーザーがフローを放棄して後で戻ってきた場合、新しいセッションを作成する必要があります。

### ステップ 4：デバイス登録ステータスの確認

パスキーを作成する前に、このデバイスがすでにこの決済トークンにバインドされているかどうかを知る必要があります。

**アテステーションリクエスト**：VTS にデバイスアテステーションリクエストを送信します。このリクエストには、ステップ 3 のセキュアトークン、包括的なブラウザデータ（タイムゾーン、画面寸法、ユーザーエージェント、色深度、JavaScript 機能）、およびトランザクションコンテキスト（金額、マーチャント情報、通貨）が含まれます。ブラウザデータは VTS が詐欺検出のためのデバイスフィンガープリントを構築するのに役立ちます。トランザクションコンテキストは、まだ購入していなくても含まれています - これは VTS が意図された使用のリスクプロファイルを理解するのに役立ちます。

**レスポンスの理解**：VTS は次に何をすべきかを教える `action` フィールドを含むレスポンスを返します。アクションが「REGISTER」の場合、このデバイスはまだこのトークンにバインドされておらず、完全なデバイスバインディングフロー（ステップ 5-9）に進む必要があります。アクションが「AUTHENTICATE」の場合、デバイスはすでにバインドされており、認証（フェーズ 4 で実際の購入に使用）に直接スキップできます。

**識別子**：レスポンスには、この特定のデバイス/トークンの組み合わせを表す `identifier` も含まれています。この識別子は残りのステップ全体で継続性を維持するために使用されます。

**このチェックが重要な理由**：このチェックにより、不要なデバイスバインディングの試行が防止されます。ユーザーがすでにこのデバイスでパスキーをセットアップしている場合、再度 OTP 検証を経る必要はありません。これにより、セキュリティを維持しながらユーザー体験が向上します。


### ステップ 5-7：OTP 検証 - ユーザーアイデンティティの証明

デバイスをバインドする必要がある場合（アクションが「REGISTER」だった場合）、VTS はユーザーが主張する本人であることを証明するためのステップアップ認証を要求します。これは OTP（ワンタイムパスワード）検証を通じて行われます。

**ステップ 5：デバイスバインディングの開始**

ステップ 4 と同じセキュアトークンとブラウザデータを含むデバイスバインディングリクエストを VTS に送信します。また、FIDO2 パスキー作成の準備をしていることを示すために意図を「FIDO」と指定します。

VTS は利用可能なステップアップ方法を返します。通常、これには SMS とメールオプションが含まれます。各方法には、選択に使用する識別子と、OTP が送信される場所を示すマスクされた値（電話番号の場合は「**PSMS」、メールの場合は「OTPEMAIL」など）が付属しています。レスポンスには「CHALLENGE」のステータスも含まれ、ユーザー検証が必要であることを示します。

**複数の方法がある理由**：SMS とメールの両方を提供することで、ユーザーに柔軟性を与えます。一部のユーザーは電話を手元に持っていないかもしれませんし、セキュリティ上の理由でメールを好むかもしれません。一部の地域では SMS 配信が他よりも優れています。オプションを提供することで、ユーザー体験と完了率が向上します。

**ステップ 6：OTP 方法の選択**

ユーザーが希望する方法（SMS またはメール）を選択し、選択した方法の識別子を含む PUT リクエストを VTS に送信します。これにより、VTS は OTP を生成し、選択したチャネルを通じてユーザーに送信します。

VTS は重要な制約を返します：`maxOTPRequestsAllowed`（通常 3）はユーザーが新しい OTP をリクエストできる回数、`maxOTPVerificationAllowed`（通常も 3）は正しいコードを入力する試行回数、`codeExpiration`（通常 5 分）は OTP が有効な時間を示します。

**ユーザー体験の考慮事項**：UI は OTP がどこに送信されたか、どのくらいの時間有効かを明確に示す必要があります。また、カウントダウンタイマーを実装し、必要に応じて（許可された制限内で）新しいコードをリクエストできるようにする必要があります。SMS 配信が遅れるケースを処理することを確認してください - 代わりにメールを試すオプションをユーザーに提供します。

**ステップ 7：OTP の検証**

ユーザーは OTP（6桁のコード）を受け取り、アプリケーションに入力します。このコードを VTS に送信して検証し、このフロー全体で使用してきた同じクライアント参照 ID を含めて継続性を維持します。

OTP が正しい場合、VTS は成功を示す空のオブジェクト（単に `{}`）で応答します。間違っている場合、エラーレスポンスを受け取り、ユーザーは再試行できます（最大試行回数まで）。

**サンドボックステスト**：Visa のサンドボックス環境では、実際の SMS/メール配信をバイパスして常に機能する「ゴールデン OTP」値 `456789` を使用できます。

### ステップ 8：パスキー作成の準備

OTP を通じてユーザーのアイデンティティが検証されたら、実際のパスキー作成の準備が整いました。

**2回目のアテステーションリクエスト**：別のデバイスアテステーションリクエストを VTS に送信しますが、今回は異なる理由コード：「PAYMENT」ではなく「DEVICE_BINDING」を使用します。また、タイプを「REGISTER」に変更します。これにより、ステップアップ認証が完了し、デバイスをバインドする準備ができたことを VTS に伝えます。

**FIDO2 チャレンジ**：VTS は FIDO2 チャレンジを生成し、JWT（JSON Web Token）ペイロードにパッケージ化します。このペイロードには、ブラウザがパスキーを作成するために必要なすべての情報が含まれています：リライングパーティ情報（Visa のドメイン）、チャレンジ自体（署名する必要があるランダム値）、ユーザー情報、およびさまざまな FIDO2 パラメータ。

**受信内容**：レスポンスには3つの重要な要素が含まれています：`endpoint`（パスキー作成に使用する特定の iFrame URL）、`identifier`（デバイス識別子）、および `payload`（FIDO2 チャレンジを含む JWT）。これら3つの要素は連携して機能します - エンドポイントはペイロードを処理する方法を知っており、識別子はすべてをこの特定のデバイスバインディングセッションに結び付けます。

**メモリに保持**：セキュアトークンと同様に、これらの値はパスキー作成プロセスの期間中のみメモリに保持する必要があります。1回限りの使用であり、すぐに期限切れになります。


### ステップ 9：iFrame を通じたパスキーの作成

**プロセス**：ステップ 8 のエンドポイント、識別子、およびペイロードを使用して Auth iFrame に POST します。iFrame は FIDO2 パスキー作成セレモニーを処理し、パスキー作成 UI をユーザーに表示します。

**レスポンス**：iFrame は `result: "COMPLETE"` を返し、`fidoBlob`（暗号化されたパスキーデータ）、`rpID`（Visa のドメイン）、およびデバイス `identifier` を含む `assuranceData` が含まれます。

**データベースに保存するもの**：`fidoBlob`（保存時に暗号化）、デバイス識別子、および作成タイムスタンプを保存し、すべてユーザープロファイルとトークン ID にリンクします。


## フェーズ 4：購入意図 - トランザクションの認証

ここで、1回限りのセットアップからトランザクションごとの操作に移ります。ユーザーが購入するたびに、認証して購入意図を作成するためにこのフェーズを経ます。

### セットアップとトランザクションの違い

フェーズ 2 と 3 はカードごと、デバイスごとに1回発生することを理解することが重要です。フェーズ 4 はユーザーが購入するたびに発生します。デバイスがすでにバインドされ、パスキーがすでに存在するため、このフェーズはセットアッププロセスよりもはるかに高速でシンプルです。

### ステップ 10：新しいトランザクションセッションの初期化

デバイスがすでにバインドされていても、各トランザクションには独自のセキュアセッションが必要です。

**新しいセッションが必要な理由**：セキュリティのベストプラクティスでは、セッショントークンは短命で1回限りの使用であるべきとされています。これにより、攻撃者がセッショントークンを傍受して再利用しようとするリプレイ攻撃が防止されます。各トランザクションに新しいセッションを要求することで、セッショントークンが侵害されても、トランザクション完了後は役に立たなくなります。

**プロセス**：これはステップ 3 と同じです - Auth iFrame と同じ2ステップハンドシェイクを行い、新しい `secureToken`、`requestID`、および `dfpSessionID` を取得します。違いはこのセッションの使用方法です - パスキーを作成する代わりに、既存のパスキーで認証します。

**セッションコンテキスト**：新しいセッションはフェーズ 3 のセットアップセッションから完全に独立しています。独自のトークン、独自の有効期限、独自のセキュリティコンテキストを持っています。この分離は意図的であり、セキュリティにとって重要です。

### ステップ 11：認証のリクエスト

新しいセッショントークンを使用して、決済の認証を行いたいことを VTS に伝えます。

**アテステーションリクエスト**：これはステップ 4 と非常によく似ていますが、1つの重要な違いがあります - デバイスはすでにバインドされています。ブラウザデータとトランザクションコンテキスト（この購入の実際の金額とマーチャント）を含む同じタイプのデバイスアテステーションリクエストを送信します。同じ理由コード「PAYMENT」とタイプ「AUTHENTICATE」を使用します。

**異なるレスポンス**：VTS はこのデバイスを認識するため（バインディングプロセスからデバイス識別子を持っている）、「REGISTER」ではなく `action: "AUTHENTICATE"` で応答します。これにより、OTP 検証を再度経ることなく、パスキー検証に直接進むことができます。

**トランザクションコンテキスト**：このリクエストにトランザクション詳細（金額、マーチャント、通貨）を含めます。VTS はこの情報を認証チャレンジに使用します。

**認証ペイロード**：アクションとともに、VTS は `endpoint`、`identifier`、および `payload` を返します - ステップ 8 と同様ですが、今回はペイロードに登録チャレンジではなく FIDO2 認証チャレンジが含まれています。チャレンジはこのトランザクションに固有であり、トランザクション詳細が含まれているため、別の購入に再利用することはできません。

### ステップ 12：iFrame を通じたパスキーの検証

これはユーザーがパスキーで認証することにより、この購入を行う権限があることを証明する場所です。

**チャレンジの送信**：ステップ 11 の認証エンドポイント、識別子、およびペイロードを使用して Auth iFrame に POST します。iFrame はこれを認証リクエスト（登録リクエストではなく）として認識し、既存のパスキーを検証する準備をします。

**ユーザーインタラクション**：iFrame はユーザーが PAN を確認し、パスキー PIN を入力するポップアップウィンドウを表示します。

**レスポンス**：iFrame は JWT base64 エンコード文字列で `assuranceData` と `fidoBlob` を返します。また、使用されたデバイスを確認するデバイス識別子も取得します。


### ステップ 13：購入指示の作成

ユーザーが認証されたら、VIC で正式な購入指示を作成します。この指示は、ユーザーがアイデンティティを検証し、これらの特定の購入条件に同意し、この特定の購入を行う意図があることを証明する事前認証のようなものです。

**購入指示リクエスト**：複数の情報を含む包括的なリクエストを VIC に送信します。`tokenId`（フェーズ 2 から）はどの支払い方法を使用するかを識別します。`assuranceData`（ステップ 12 の `fidoBlob` を含む）はユーザーが認証されたことを証明します。`mandates` セクションは購入を説明します - 金額、通貨、マーチャントカテゴリ、説明、および拒否しきい値などの制約。`appInstance` セクションは詐欺検出のためのデバイス情報を提供します。`consumerPrompt` にはユーザーが購入しているものの概要を含めることができ、紛争解決に役立つ場合があります。

**マンデートの理解**：マンデート構造は強力で柔軟です。請求できる最大金額を指定する `declineThreshold` を設定できます。指示が有効な期間を制限するために `effectiveUntilTime` を設定できます。同じ指示の複数回の使用を許可するために `quantity` を指定できます（ただし、単一の購入では通常 1 です）。`merchantCategoryCode` はカテゴリ分類と詐欺検出に役立ちます。

**デバイスとリスク情報**：`appInstance` セクションには詳細なデバイス情報が含まれます - 国コード、デバイス ID、IP アドレス、デバイスモデルとタイプ、ユーザーエージェント、およびアプリケーション名。この情報は VIC の詐欺検出システムにとって重要です。異常なパターン（デバイスが突然別の国に現れるなど）は追加の検証をトリガーできます。

**指示 ID**：VIC はこのすべての情報を処理し、認証を検証し、トークンステータスを確認し、購入指示を作成します。`instructionId` で応答します - この特定の購入意図のための一意の識別子。この ID は決済認証情報を取得するための認可です。

**指示が表すもの**：指示 ID は「このユーザーは認証され、Y マーチャントから X 金額を購入する意図があり、そうする権限がある」というチケットと考えてください。これはまだ実際の支払いではありません - 支払いを作成するための認可です。

**一時ストレージ**：指示 ID はトランザクション期間中メモリに保持する必要があります。監査目的でログに記録することもできますが、長期的に永続化する必要はありません。トランザクションが完了（または失敗）すると、指示 ID は役に立たなくなります。

**有効期限**：購入指示には限られた有効期間があり、通常数分です。このウィンドウ内で指示 ID を使用して決済認証情報を取得しない場合、期限切れになり、新しい認証でやり直す必要があります。これにより、攻撃者が指示 ID を盗んで後で使用することが防止されます。


## フェーズ 5：購入完了 - クリプトグラムの生成と使用

これは実際の決済認証情報が生成され、購入を完了するために使用される最終フェーズです。ここで、前のフェーズからのすべてのセキュリティ対策が組み合わさって、安全で1回限りの決済認証情報が作成されます。

### ステップ 14：決済クリプトグラムのリクエスト

指示 ID を手に入れたら、VIC から実際の決済認証情報をリクエストします。

**認証情報リクエスト**：`tokenId`（支払い方法を識別）、`instructionId`（認可を証明）、および詳細な `transactionData`（マーチャント国、金額、通貨、マーチャント URL と名前、およびトランザクション参照 ID）を含むリクエストを VIC に送信します。トランザクション参照 ID は通常、指示 ID と同じで、明確な監査証跡を作成します。

**レスポンス**：VIC は `signedPayload` と呼ばれる JWT（JSON Web Token）にパッケージ化されたクリプトグラムを返します。レスポンスには指示が履行されたことを示す「COMPLETED」のステータスも含まれます。

**JWT のデコード**：任意の JWT ライブラリを使用して署名されたペイロードをデコードできます。内部には、決済情報を含む `dynamicData` 配列があります。`paymentToken` はクリプトグラムです。`dynamicDataValue` は動的 CVV2 です。`tokenExpirationMonth` と `tokenExpirationYear` はトークンの有効期限を示します。`dynamicDataExpiration` は Unix タイムスタンプです。

### ステップ 15：マーチャントへの支払い送信

これでクリプトグラムを持っており、マーチャントとの購入を完了する準備ができました。

**決済データの抽出**：デコードされた JWT から、`paymentToken`（クリプトグラム）、`dynamicDataValue`（動的 CVV2）、および有効期限を抽出します。また、自分の記録からトランザクション金額と通貨も持っています。

**マーチャントの視点**：マーチャントの視点からは、これは通常のカード決済のように見えます。カード番号のように見えるもの（クリプトグラム）、CVV2（動的値）、有効期限、およびトランザクション金額を受け取ります。他のカードトランザクションと同様に、通常の決済ゲートウェイを通じて処理します。

**マーチャントが知らないこと**：マーチャントはユーザーの実際のカード番号を見ることはありません。これがトークン化された支払いであることを知りません。発生したパスキー認証について知りません。彼らの視点からは、単なるカード決済です。これは意図的です - マーチャントがこのセキュアな支払い方法をサポートするためにシステムを変更する必要がないことを意味します。

**認可フロー**：マーチャントがクリプトグラムを決済プロセッサに送信すると、最終的に Visa の認可システムに到達します。Visa はクリプトグラムを認識し、元のトランザクション詳細に対して検証し、以前に使用されていないことを確認し、期限切れでないことを検証します。すべてが確認されれば、Visa はトランザクションを認可し、マーチャントは承認を受け取ります。

**拒否の処理**：トランザクションが拒否された場合（残高不足、期限切れのトークン、無効なクリプトグラムなど）、マーチャントからエラーを受け取ります。これをユーザーに明確に提示し、別の支払い方法を試す、カード情報を更新する、または銀行に連絡するなどのオプションを提供する必要があります。

### ステップ 16：トランザクションの確認

マーチャントが支払いが成功したことを確認した後、VIC に最終確認を送信します。

**確認リクエスト**：`instructionId` と注文ステータスが「COMPLETE」であることを示す確認データを含むリクエストを VIC に送信します。

**レスポンス**：VIC はクライアント参照 ID を含む確認応答を返します。

**保存するもの**：データベースには完全なトランザクションレコードを保存する必要があります。指示 ID（参照用）、トランザクション金額と通貨、マーチャント名、トランザクションステータス（「COMPLETED」）、およびトランザクションが作成され完了したときのタイムスタンプを含めます。このレコードをユーザープロファイルとトークン ID にリンクします。これにより完全な監査証跡が作成され、ユーザーにトランザクション履歴が提供されます。

**トランザクションライフサイクルの完了**：確認を送信すると、トランザクションは完了です。ユーザーは実際のカード番号をシステムやマーチャントに公開することなく、トークン化された決済認証情報とパスキー認証を使用して購入に成功しました。


## データストレージの考慮事項

API フローに基づいて、決済機能を有効にするために特定のデータを永続化する必要があります。このデータをどのように構造化して保存するかは、特定のビジネス要件とアーキテクチャによって異なります。

### コアデータ要素

**ユーザー識別**：システム内の特定のユーザーに決済トークンとパスキーを関連付ける方法が必要です。

**決済トークンデータ**：ステップ 2 の `vProvisionedTokenID` は、後続のすべての決済操作に必要です。`tokenReferenceID` と最後の4桁や有効期限などの表示情報も保存することをお勧めします。

**パスキー認証データ**：ステップ 9 の `fidoBlob` とデバイス `identifier` は、将来の認証フローに必要です。`fidoBlob` は保存時に暗号化することを検討してください。

**トランザクションレコード**：ビジネスニーズに応じて、指示 ID、金額、およびステータスを含むトランザクション履歴を保存することをお勧めします。


## セキュリティベストプラクティス

この決済統合を実装する際は、以下のセキュリティプラクティスを考慮してください：

**データ暗号化**：カードデータは Visa の JWE 形式を使用して暗号化する必要があります。`fidoBlob` などの機密データは保存時に暗号化することを検討してください。

**セッション管理**：Auth iFrame からの `secureToken` と VIC からの `instructionId` は、短命で1回限りの使用を目的として設計されています。

**HTTPS**：Visa のサービスとのすべての通信には HTTPS が必要です。

**ロギング**：機密決済データのロギングは避けてください。必要に応じて参照にはトークン ID と最後の4桁を使用してください。

注意：AWS にデプロイする場合、セキュリティは AWS とアプリケーション間の共有責任です。

## 実装の次のステップ

### Visa の技術ドキュメントを確認

このガイドは概念的なフレームワークとプロセスフローを提供します。実際の実装には、正確なリクエスト/レスポンススキーマ、エラーコードとその意味、暗号化要件とキー管理、およびレート制限とスロットリングポリシーを含む Visa の詳細な API ドキュメントが必要です。

### 開発環境のセットアップ

テスト用に Visa からサンドボックス認証情報を取得します。有効な SSL 証明書でアプリケーションの HTTPS を設定します。ユーザープロファイル、トークン、パスキー、およびトランザクションをサポートするデータベーススキーマをセットアップします。保存時に機密データを保護するための暗号化ユーティリティを実装します。

### 段階的に構築

フェーズ 2（トークン化）から始め、カードを正常に登録してトークンをプロビジョニングできることを確認します。次にフェーズ 3（パスキーセットアップ）を追加し、OTP 検証を含む完全なデバイスバインディングフローをテストします。最後に、フェーズ 4-5（トランザクションフロー）を実装し、エンドツーエンドの購入をテストします。本番環境に移行する前にサンドボックスで徹底的にテストしてください。

### アーキテクチャガイドを参照

AWS AgentCore または MCP サーバーを使用したエージェントの実装の詳細については、別のアーキテクチャガイドを参照してください。そのドキュメントでは、エージェントオーケストレーションパターン、状態管理、エラー回復、およびデプロイメントの考慮事項について説明しています。

## サポートとリソース

- **Visa Developer Portal**：[developer.visa.com](https://developer.visa.com)
- **VTS ドキュメント**：[developer.visa.com/capabilities/vts](https://developer.visa.com/capabilities/vts)
- **VIC ドキュメント**：[developer.visa.com/capabilities/vic](https://developer.visa.com/capabilities/vic)
- **FIDO2 仕様**：[fidoalliance.org/specifications](https://fidoalliance.org/specifications/)
- **AWS AgentCore**：別のアーキテクチャガイドを参照

